var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#p5fip-fast-image-processing","title":"p5.FIP (Fast Image Processing)","text":"<p>Real-time post-processing library for p5.js.</p>"},{"location":"index.html#what-is-it","title":"What is it?","text":"<p>p5.FIP is a library that allows you to add post-processing / image-processing effects to your p5.js sketch. </p> <p>Left and right arrow keys cycle filters, up and down arrow keys cycle images.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>44 Effects</li> <li>Hardware Accelerated</li> <li>Documented</li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>To use FIP you can include it in your index.html file: <pre><code>    &lt;head&gt;\n    &lt;!-- ...--&gt;\n    &lt;script src=\"https://prontopablo.github.io/p5.FIP/assets/javascripts/p5.FIP.js\"&gt;&lt;/script&gt;\n    &lt;!-- ...--&gt;\n    &lt;/head&gt;\n</code></pre> Alternatively you can download the p5.FIP.js file from releases and bring it into your project files: <pre><code>    &lt;head&gt;\n    &lt;!-- ...--&gt;\n    &lt;script src=\"p5.FIP.js\"&gt;&lt;/script&gt;\n    &lt;!-- ...--&gt;\n    &lt;/head&gt;\n</code></pre></p> <p>The reference for each shader can be found in the sidebar of this website.</p>"},{"location":"index.html#examples","title":"Examples","text":"<p>Example sketches can be found in this collection here and they are also included in the examples folder on GitHub. </p>"},{"location":"index.html#p5js-library-guidelines","title":"p5.js Library Guidelines","text":"<p>In accordance with the p5.js library guidelines:</p> <ol> <li>FIP has no dependencies.</li> <li>Examples are included.</li> <li>Source Code</li> <li>Keywords: image-processing, post-processing, filters.</li> <li>Last update: 25/02/24.</li> </ol>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>I welcome contributions from the community to make p5.FIP better. If you have any suggestions, bug fixes, or new features to add, feel free to create a pull request.</p>"},{"location":"index.html#acknowledgments","title":"Acknowledgments","text":"<p>Many of these shaders were adapted from existing solutions in other programming languages, in these cases, the links to the original shaders can be found at the top of each .glsl file.</p> <p>A list of existing Processing image processing libraries can be found here.</p>"},{"location":"antiAliasing.html","title":"Anti-aliasing","text":"<p>Performs basic anti-aliasing using a 2x2 super-sampling technique. Takes four samples per pixel and averages them to smooth out edges.</p>"},{"location":"antiAliasing.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>strength</code> Float:  Default: <code>1.0</code> Controls the size of the offset for super-sampling. Larger values result in stronger anti-aliasing.</p>"},{"location":"antiAliasing.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader antiAliasing;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  antiAliasing = loadShader(\"antiAliasing.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  antiAliasing.set(\"strength\", 2.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(antiAliasing);\n}\n</code></pre>"},{"location":"bilateral.html","title":"Bilateral","text":"<p>Blurs while preserving edges based on spatial and intensity (color) differences.</p>"},{"location":"bilateral.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>sigmaSpace</code> Float: Spatial standard deviation for calculating spatial differences. Default: <code>20.0</code> <code>sigmaColor</code> Float: Intensity (color) standard deviation for calculating color differences. Default: <code>0.1</code></p>"},{"location":"bilateral.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader bilateral;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  bilateral = loadShader(\"bilateral.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  bilateral.set(\"sigmaSpace\", 20.0);\n  bilateral.set(\"sigmaColor\", 0.1);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(bilateral);\n}\n</code></pre>"},{"location":"blend.html","title":"Blend","text":"<p>Blends textures together based on a mix factor and blending type.</p>"},{"location":"blend.html#parameters","title":"Parameters","text":"<p><code>texture1</code> Texture: The first texture to be blended. Default: <code>undefined</code> <code>texture2</code> Texture: The second texture to be blended. Default: <code>undefined</code> <code>mixFactor</code> Float: How much weight to give each picture in the blending. A value of 0.0 only outputs texture1, 1.0 only outputs texture2. Default: <code>0.5</code> <code>blendingMode</code> Int: Which blending mode to use. Below is a table of the values and their respective blend modes. Default: <code>1.0</code></p> blendingMode Blend Mode 1 Additive Blending 2 Subtract Blending 3 Multiplicative Blending 4 Screen Blending 5 Overlay Blending 6 Darken Blending 7 Lighten Blending 8 Difference Blending 9 Exclusion Blending 10 Behind Blending 11 Dissolve Blending 12 Hue Blending 13 Normal Blending Default Linear Interpolation"},{"location":"blend.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader blend;\n\nPImage ireland;\nPImage bird;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  blend = loadShader(\"blend.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n  bird = loadImage(\"bird.jpg\");\n\n  blend.set(\"texture1\", ireland); // Blend requires these 2 textures to be passed into it. \n  blend.set(\"texture2\", bird);\n  blend.set(\"mixFactor\", 0.5); // Equally blend the images\n  blend.set(\"blendingMode\", 0); // Use linear interpolation blending\n}\n\nvoid draw() {\n  background(255);\n  filter(blend);\n}\n</code></pre> Images to be blended Blended image"},{"location":"bloom.html","title":"Bloom","text":"<p>Adds a glow effect using a combination of blurring and blending techniques.</p>"},{"location":"bloom.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>intensity</code> Float: The strength of the glow effect. A higher value intensifies the glow. Default: <code>0.5</code> <code>glow</code> Float: The extent of the glow, controlled by the blur radius. Should be within the range [0.0, 8.0]. Default: <code>0.0</code></p>"},{"location":"bloom.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader bloom;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  bloom = loadShader(\"bloom.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  bloom.set(\"intensity\", 0.5);\n  bloom.set(\"glow\", 2.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(bloom);\n}\n</code></pre>"},{"location":"boxBlur.html","title":"Box Blur","text":"<p>Blurs using a simple box blur algorithm.</p>"},{"location":"boxBlur.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>blurRadius</code> Int: The radius of the box blur. Controls the extent of blurring. Default: <code>3</code></p>"},{"location":"boxBlur.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader boxBlur;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  boxBlur = loadShader(\"boxBlur.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  boxBlur.set(\"blurRadius\", 5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(boxBlur);\n}\n</code></pre>"},{"location":"brightness.html","title":"Brightness","text":"<p>Adjusts the brightness.</p>"},{"location":"brightness.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>brightness</code> Float: The factor by which to adjust the brightness. A value less than 1.0 darkens the image, while a value greater than 1.0 brightens it. Default: <code>0.7</code></p>"},{"location":"brightness.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader brightness;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  brightness = loadShader(\"brightness.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  brightness.set(\"brightness\", 0.7);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(brightness);\n}\n</code></pre>"},{"location":"cannyEdgeDetection.html","title":"Canny Edge Detection","text":"<p>Detects edges using the Canny edge detection algorithm.</p>"},{"location":"cannyEdgeDetection.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>thresholdLow</code> Float: The lower threshold for edge detection. Pixels with intensity gradients below this threshold will be suppressed. Default: <code>0.1</code> <code>thresholdHigh</code> Float: The higher threshold for edge detection. Pixels with intensity gradients above this threshold will be considered strong edges. Default: <code>0.3</code></p>"},{"location":"cannyEdgeDetection.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader cannyEdgeDetection;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  cannyEdgeDetection = loadShader(\"cannyEdgeDetection.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  cannyEdgeDetection.set(\"thresholdLow\", 0.1);\n  cannyEdgeDetection.set(\"thresholdHigh\", 0.3);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(cannyEdgeDetection);\n}\n</code></pre>"},{"location":"cartoon.html","title":"Cartoon","text":"<p>Adds a cartoon effect by emphasizing edges and darkening them.</p>"},{"location":"cartoon.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>edgeThreshold</code> Float: The threshold value that determines whether a pixel is considered an edge pixel based on the difference between the center pixel and its neighbors. Default: <code>0.1</code></p>"},{"location":"cartoon.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader cartoon;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  cartoon = loadShader(\"cartoon.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  cartoon.set(\"edgeThreshold\", 0.1);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(cartoon);\n}\n</code></pre>"},{"location":"contrast.html","title":"Contrast","text":"<p>Adjusts the contrast.</p>"},{"location":"contrast.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>contrast</code> Float: The contrast adjustment factor. A value of 1.0 leaves the contrast unchanged, while higher values increase contrast, and lower values decrease contrast. Default: <code>2.0</code></p>"},{"location":"contrast.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader contrast;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  contrast = loadShader(\"contrast.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  contrast.set(\"contrast\", 1.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(contrast);\n}\n</code></pre>"},{"location":"crt.html","title":"CRT","text":"<p>Recreates the effects of an old CRT television with visible scanlines, spherical warping, and vignette.</p>"},{"location":"crt.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>thresholdLow</code> Float: Threshold to highlight edges. Pixels with intensity gradients below this threshold are considered non-edges. Default: <code>0.1</code> <code>thresholdHigh</code> Float: Threshold to perform hysteresis and link edges. Pixels with intensity gradients above this threshold are fully considered as edges. Default: <code>0.3</code> <code>scanlineWeight</code> Float: Weight of the scanlines effect. Default: <code>0.1</code> <code>brightness</code> Float: Adjusts the overall brightness of the image. Default: <code>2.5</code> <code>distortion</code> Float: Controls the amount of spherical warping. Default: <code>0.02</code></p>"},{"location":"crt.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader crt;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  crt = loadShader(\"crt.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  crt.set(\"thresholdLow\", 0.1);\n  crt.set(\"thresholdHigh\", 0.3);\n  crt.set(\"scanlineWeight\", 0.1);\n  crt.set(\"brightness\", 2.5);\n  crt.set(\"distortion\", 0.02);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(crt);\n}\n</code></pre>"},{"location":"deform.html","title":"Deform","text":"<p>Uses sine waves to deform.</p>"},{"location":"deform.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>deformationAmount</code> Float: The amount of deformation to apply based on a sine wave. Default: <code>0.1</code></p>"},{"location":"deform.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader deform;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  deform = loadShader(\"deform.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  deform.set(\"deformationAmount\", 0.1);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(deform);\n}\n</code></pre>"},{"location":"differenceOfGaussian.html","title":"Difference of Gaussian","text":"<p>Applies two Gaussian blurs to the input texture and calculates the Difference of Gaussian.</p>"},{"location":"differenceOfGaussian.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>undefined</code> <code>radius1</code> Float: The radius of the first Gaussian blur. Default: <code>10.0</code> <code>radius2</code> Float: The radius of the second Gaussian blur. Default: <code>1.0</code></p>"},{"location":"differenceOfGaussian.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader differenceOfGaussian;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  differenceOfGaussian = loadShader(\"differenceOfGaussian.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  differenceOfGaussian.set(\"resolution\", float(width), float(height));\n  differenceOfGaussian.set(\"radius1\", 10.0);\n  differenceOfGaussian.set(\"radius2\", 1.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(differenceOfGaussian);\n}\n</code></pre>"},{"location":"dilate.html","title":"Dilate","text":"<p>Dilates the input image to increase light areas. Samples surrounding pixels and combines them to produce a dilated effect.</p>"},{"location":"dilate.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> </p>"},{"location":"dilate.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader dilate;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  dilate = loadShader(\"dilate.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(dilate);\n}\n</code></pre>"},{"location":"dithering.html","title":"Dithering","text":"<p>Applies dithering to an image, a technique commonly used to simulate additional colors and reduce banding in lower bit-depth images.</p>"},{"location":"dithering.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> </p>"},{"location":"dithering.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader dithering;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  dithering = loadShader(\"dithering.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(dithering);\n}\n</code></pre>"},{"location":"dot.html","title":"Dot","text":"<p>Emulates a seven-segment display by grouping pixels into dots.</p>"},{"location":"dot.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>dotSize</code> Float: The size of each dot in the display. Default: <code>0.008</code> </p>"},{"location":"dot.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader dot;\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  dot = loadShader(\"dot.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n  dot.set(\"dotSize\", 0.008);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(dot);\n}\n</code></pre>"},{"location":"duoTone.html","title":"Duotone","text":"<p>Applies a two-tone color effect.</p>"},{"location":"duoTone.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>tone1</code> Vec2: The RGB values of the first tone. Default: <code>(0.8627, 0.6275, 0.0)</code> <code>tone2</code> Vec2: The RGB values of the second tone. Default: <code>(0.4157, 0.0118, 0.5647)</code></p>"},{"location":"duoTone.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader duoTone;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  duoTone = loadShader(\"duoTone.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  duoTone.set(\"tone1\", 0.8627, 0.6275, 0.0);\n  duoTone.set(\"tone2\", 0.4157, 0.0118, 0.5647);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(duoTone);\n}\n</code></pre>"},{"location":"edgePreservingSmooth.html","title":"Edge Preserving Smooth","text":"<p>Applies an edge-preserving filter to the input texture, emphasizing edges while smoothing other areas.</p>"},{"location":"edgePreservingSmooth.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>threshold</code> Float: The threshold value that determines whether to preserve the original pixel color or use the local average. Default: <code>0.2</code></p>"},{"location":"edgePreservingSmooth.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader edgePreservingFilter;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  edgePreservingFilter = loadShader(\"edgePreservingFilter.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  edgePreservingFilter.set(\"threshold\", 0.2);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(edgePreservingFilter);\n}\n</code></pre>"},{"location":"emboss.html","title":"Emboss","text":"<p>Applies an emboss effect to the input texture, creating a 3D appearance. This is achieved by calculating the gradient of the pixel values and normalizing the result.</p>"},{"location":"emboss.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> </p>"},{"location":"emboss.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader emboss;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  emboss = loadShader(\"emboss.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(emboss);\n}\n</code></pre>"},{"location":"erosion.html","title":"Erosion","text":"<p>Computes the minimum pixel value within a local neighborhood. The structuring element is a square kernel centered at each pixel, and its size is determined by the specified radius.</p>"},{"location":"erosion.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>radius</code> Int: The radius of the erosion operation. Default: <code>3</code></p>"},{"location":"erosion.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader erosion;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  erosion = loadShader(\"erosion.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  erosion.set(\"radius\", 3);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(erosion);\n}\n</code></pre>"},{"location":"flip.html","title":"Flip","text":"<p>Flips the input texture horizontally and/or vertically based on specified parameters.</p>"},{"location":"flip.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>flipHorizontal</code> Boolean:  If <code>true</code>, flips the texture horizontally. Default: <code>false</code> <code>flipVertical</code> Boolean:  If <code>true</code>, flips the texture vertically. Default: <code>true</code></p>"},{"location":"flip.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader flip;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  flip = loadShader(\"flip.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  flip.set(\"flipHorizontal\", true);\n  flip.set(\"flipVertical\", false);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(flip);\n}\n</code></pre>"},{"location":"gamma.html","title":"Gamma","text":"<p>Applies gamma correction to the input texture color.</p>"},{"location":"gamma.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>gamma</code> Float:  Gamma value for correction. Default: <code>2.2</code></p>"},{"location":"gamma.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader gamma;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  gamma = loadShader(\"gamma.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  gamma.set(\"gamma\", 2.2);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(gamma);\n}\n</code></pre>"},{"location":"gaussianBlur.html","title":"Gaussian Blur","text":"<p>Applies a Gaussian blur to the input texture.</p>"},{"location":"gaussianBlur.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code></p>"},{"location":"gaussianBlur.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader gaussianBlur;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  gaussianBlur = loadShader(\"gaussianBlur.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(gaussianBlur);\n}\n</code></pre>"},{"location":"glitch.html","title":"Glitch","text":"<p>The RGB channels are separated and displaced, then original and glitched colors are mixed.</p>"},{"location":"glitch.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>mouse</code> Vec2: The position of the mouse pointer. Default: <code>vec2(0.0)</code></p>"},{"location":"glitch.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader glitch;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  glitch = loadShader(\"glitch.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  glitch.set(\"resolution\", width, height);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  glitch.set(\"mouse\", float(mouseX), float(mouseY));\n  filter(glitch);\n}\n</code></pre>"},{"location":"grayscale.html","title":"Grayscale","text":"<p>Converts the input texture to grayscale using the luminance method, which is a weighted sum of the color channels.</p>"},{"location":"grayscale.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code></p>"},{"location":"grayscale.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader grayscale;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  grayscale = loadShader(\"grayscale.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(grayscale);\n}\n</code></pre>"},{"location":"halftone.html","title":"Halftone","text":"<p>Applies a halftone effect by converting texture coordinates to screen space, defining cells based on the specified size, and calculating dots within each cell.</p>"},{"location":"halftone.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>cellSize</code> Float: The size of each halftone cell. Default: <code>20.0</code> <code>threshold</code> Float: The threshold value for dot creation. A higher value results in fewer dots. Default: <code>0.8</code></p>"},{"location":"halftone.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader halftone;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  halftone = loadShader(\"halftone.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  halftone.set(\"resolution\", width, height);\n  halftone.set(\"cellSize\", 5.0);\n  halftone.set(\"threshold\", 0.2);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(halftone);\n}\n</code></pre>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#option-1-install-with-processing-contribution-manager","title":"Option 1: Install with Processing Contribution Manager","text":"<p>The library is currently being reviewed by Processing Org, once it has been accepted it will be available from the Processing Contribution Manager</p> <p></p> The Processing Contribution Manager can be found in Sketch &gt; Import Library &gt; Manage Libraries"},{"location":"installation.html#option-2-install-manually","title":"Option 2: Install Manually","text":"<p>Download and then unzip FIP. Then put the extracted folder into the \"libraries\" folder of Processing.</p>"},{"location":"invertColors.html","title":"Invert Colors","text":"<p>Inverts the colors of a texture.</p>"},{"location":"invertColors.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code></p>"},{"location":"invertColors.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader invertColors;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  invertColors = loadShader(\"invertColors.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(invertColors);\n}\n</code></pre>"},{"location":"issues.html","title":"Issues","text":"<p>Below are some common issues people have when using FIP and how to resolve them. If your issue is not listed below, please report it here and I'll try to help you or fix it.</p>"},{"location":"issues.html#out-of-date-graphics-drivers","title":"Out of date graphics drivers","text":"<p>As FIP runs GLSL shaders on the GPU, make sure you update to the latest graphics drivers for your GPU (how?), otherwise you may see some visual glitches.</p>"},{"location":"issues.html#not-passing-textures","title":"Not passing textures","text":"<p>Some shaders have required parameters and will not work if these parameters are not passed into them. Below we use the blend shader but fail to pass it the textures we want to blend, so it does nothing.</p> <pre><code>import fip.*;\n\nPShader blend;\n\nPImage ireland;\nPImage bird;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  blend = loadShader(\"blend.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n  bird = loadImage(\"bird.jpg\");\n\n  // blend.set(\"texture1\", ireland); - Blend requires these 2 textures to be passed into it.\n  // blend.set(\"texture2\", bird);\n\n  blend.set(\"mixFactor\", 0.5);\n  blend.set(\"blendingMode\", 0);\n}\n\nvoid draw() {\n  background(255);\n  filter(blend);\n}\n</code></pre> Required parameters not set, shader does nothing  Image when textures are passed"},{"location":"kuwahara.html","title":"Kuwahara","text":"<p>Local image processing technique used for noise reduction and edge preservation. It divides the image into quadrants, calculates the mean and variance of color values in each quadrant, and selects the quadrant with the minimum color variance. This results in a smoothed version of the original image.</p>"},{"location":"kuwahara.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code></p>"},{"location":"kuwahara.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader kuwahara;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  kuwahara = loadShader(\"kuwahara.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(kuwahara);\n}\n</code></pre>"},{"location":"laplacianEdgeEnhancement.html","title":"Laplacian Edge Enhancement","text":"<p>Enhances image details by emphasizing edges through Laplacian filtering.</p>"},{"location":"laplacianEdgeEnhancement.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>amount</code> Float: Controls the strength of the enhancement. Higher values result in more pronounced edges. Default: <code>1.5</code></p>"},{"location":"laplacianEdgeEnhancement.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader laplacianEdgeEnhancement;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  laplacianEdgeEnhancement = loadShader(\"laplacianEdgeEnhancement.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  laplacianEdgeEnhancement.set(\"amount\", 1.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(laplacianEdgeEnhancement);\n}\n</code></pre>"},{"location":"linocut.html","title":"Linocut","text":"<p>Simulates a linocut effect by converting the input image to grayscale and applying a threshold to distinguish between ink and paper regions.  </p>"},{"location":"linocut.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>threshold</code> Float: The threshold value to determine the cutoff between ink and paper colors. Values above the threshold represent ink, while values below represent paper. Default: <code>0.4</code> <code>inkColor</code> Vec3: The color of the ink. This is a RGB vector, where each component is in the range [0, 1]. Default: <code>(0.4, 0.4, 1.0)</code> <code>paperColor</code> Vec3: The color of the paper. This is a RGB vector, where each component is in the range [0, 1]. Default: <code>(1.0, 1.0, 1.0)</code></p>"},{"location":"linocut.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader linocut;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  linocut = loadShader(\"linocut.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  linocut.set(\"threshold\", 0.4);\n  linocut.set(\"inkColor\", 0.4, 0.4, 1.0);\n  linocut.set(\"paperColor\", 1.0, 1.0, 1.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(linocut);\n}\n</code></pre>"},{"location":"mosaic.html","title":"Mosaic","text":"<p>Applies a mosaic effect to an input texture.</p>"},{"location":"mosaic.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>mosaicSize</code> Float: Size of the mosaic cells. A higher value results in larger mosaic cells. Default: <code>40.0</code></p>"},{"location":"mosaic.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader mosaic;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  mosaic = loadShader(\"mosaic.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  mosaic.set(\"mosaicSize\", 20.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(mosaic);\n}\n</code></pre>"},{"location":"motionBlur.html","title":"Motion Blur","text":"<p>Blurs an image by simulating motion in a specified direction.</p>"},{"location":"motionBlur.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>blurAmount</code> Float: The amount of blur to apply. Higher values result in more significant blur. Default: <code>10.0</code></p>"},{"location":"motionBlur.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader motionBlur;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  motionBlur = loadShader(\"motionBlur.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  motionBlur.set(\"texOffset\", 1.0, 0.0); // Horizontal motion blur\n  motionBlur.set(\"blurAmount\", 20.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(motionBlur);\n}\n</code></pre>"},{"location":"pixelate.html","title":"Pixelate","text":"<p>Pixelates an image by rounding each pixel to a fixed grid based on the specified pixel size.</p>"},{"location":"pixelate.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>pixelSize</code> Float: The size of each pixel in the pixel grid. Default: <code>10.0</code></p>"},{"location":"pixelate.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader pixelate;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  pixelate = loadShader(\"pixelate.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  pixelate.set(\"pixelSize\", 0.01);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(pixelate);\n}\n</code></pre>"},{"location":"quantization.html","title":"Quantization","text":"<p>Reduces the number of colors in an image through quantization.</p>"},{"location":"quantization.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>shades</code> Int: Number of shades to quantize the colors to. Default: <code>4.0</code></p>"},{"location":"quantization.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader quantization;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  quantization = loadShader(\"quantization.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  quantization.set(\"shades\", 4);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(quantization);\n}\n</code></pre>"},{"location":"resources.html","title":"List of Resources","text":"<p>As I've developed FIP I've realised there is a lack of documentation for Processing shaders. Below is a list of useful resources grouped by category.</p>"},{"location":"resources.html#learning-about-processing-shaders","title":"Learning about Processing shaders","text":"<ul> <li> <p>If you're writing shaders for Processing, I would highly recommend this archived tutorial. </p> </li> <li> <p>The replies to this Reddit post list various resources and examples.</p> </li> <li> <p>This Stack Overflow thread goes over some troubleshooting.</p> </li> <li> <p>What's the difference between shader() and filter()?</p> </li> </ul>"},{"location":"resources.html#processing-vs-p5js-shaders","title":"Processing vs. p5.js shaders","text":"<ul> <li> <p>Processing uses \"full OpenGL\" but uses the specifications of OpenGL ES. </p> </li> <li> <p>p5.js uses WebGL which is a JavaScript API based on GL_ES. WebGL is specifically designed to work within web browsers and is a subset of the full OpenGL specification. The GL_ES (OpenGL ES) variant is suitable for embedded systems, such as mobile devices, and is commonly used in web development.</p> </li> </ul>"},{"location":"resources.html#other-processing-shader-projects","title":"Other Processing shader projects","text":"<ul> <li>Processing Shader Examples</li> <li>PixelFlow</li> <li>Compute Shader</li> <li>Processing Image Processing</li> <li>Filters4Processing</li> <li>Lygia</li> </ul>"},{"location":"ripple.html","title":"Ripple","text":"<p>Creates a ripple effect using sine function.</p>"},{"location":"ripple.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>rippleFrequency</code> Float: The frequency of the ripples. Default: <code>50.0</code> <code>rippleAmplitude</code> Float: The amplitude or strength of the ripples. Default: <code>0.01</code> <code>rippleCenterOffset</code> Vec2: The offset of the ripple center from the center of the screen. Default: <code>vec2(0.0)</code></p>"},{"location":"ripple.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader ripple;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  ripple = loadShader(\"ripple.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  ripple.set(\"resolution\", width, height);\n  ripple.set(\"rippleFrequency\", 50.0);\n  ripple.set(\"rippleAmplitude\", 0.01);\n  ripple.set(\"rippleCenterOffset\", 0.0, 0.0);\n\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(ripple);\n}\n</code></pre>"},{"location":"rotate.html","title":"Rotate","text":"<p>Rotates an input texture based on a specified rotation angle in degrees. It ensures that the resulting rotated coordinates are within the texture bounds. If the rotated coordinates fall outside the bounds, the pixel becomes transparent. </p>"},{"location":"rotate.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>rotationAngleDegrees</code> Float: Rotation angle in degrees. Default: <code>45.0</code></p>"},{"location":"rotate.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader rotate;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  rotate = loadShader(\"rotate.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  rotate.set(\"rotationAngleDegrees\", 45.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(rotate);\n}\n</code></pre>"},{"location":"saturation.html","title":"Saturation","text":"<p>Adjusts the saturation of an input texture. It operates by converting the original color to grayscale (luminance) and then interpolating between the grayscale version and the original color based on the saturation parameter.</p>"},{"location":"saturation.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>saturation</code> Float: Controls the saturation of the image. A value of 0.0 results in a grayscale image, while higher values increase saturation. Default: <code>2.0</code></p>"},{"location":"saturation.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader saturation;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  saturation = loadShader(\"saturation.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  saturation.set(\"saturation\", 1.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(saturation);\n}\n</code></pre>"},{"location":"sepia.html","title":"Sepia","text":"<p>Converts the input image to a sepia-toned version using a specific color transformation.</p>"},{"location":"sepia.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code></p>"},{"location":"sepia.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader sepia;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  sepia = loadShader(\"sepia.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(sepia);\n}\n</code></pre>"},{"location":"settingParameters.html","title":"Setting Parameters","text":"<p>Each effect has parameters that you can edit using .set(). The reference page for each effect lists the parameters and what they do.</p> <p>The example below sets the blur amount of the motion blur shader to 100 (the default value is 10). <pre><code>import fip.*;\n\nPShader motionBlur;\nPImage ireland;\n\nvoid setup() {\n    size(1000, 1000, P3D);\n\n    motionBlur = loadShader(\"motionBlur.glsl\");\n\n    motionBlur.set(\"blurAmount\", 100.0); // Set the parameter named \"blurAmount\" to 100.\n\n    ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n    image(ireland, 0, 0, width, height); \n\n    filter(motionBlur);\n}\n</code></pre></p> blurAmount = 10 blurAmount = 100"},{"location":"sharpen.html","title":"Sharpen","text":"<p>Applies a sharpening effect to the input texture using a convolution kernel. It calculates the sharpened color of each pixel by enhancing the details in the center pixel and subtracting a fraction of the neighboring pixels.</p>"},{"location":"sharpen.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>sharpness</code> Float: The intensity of the sharpening effect.  Default: <code>1.5</code></p>"},{"location":"sharpen.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader sharpen;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  sharpen = loadShader(\"sharpen.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  sharpen.set(\"sharpness\", 1.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(sharpen);\n}\n</code></pre>"},{"location":"sketch.html","title":"Sketch","text":"<p>Applies the Sobel operator for edge detection, creating an ink-like effect on an input texture.</p>"},{"location":"sketch.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>threshold</code> Float: The threshold for edge intensity. Values above this threshold will be considered edges, creating the ink-like effect. Default: <code>0.15</code></p>"},{"location":"sketch.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader sketch;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  sketch = loadShader(\"sketch.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  sketch.set(\"threshold\", 0.15);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(sketch);\n}\n</code></pre>"},{"location":"sobelEdgeDetection.html","title":"Sobel Edge Detection","text":"<p>Performs edge detection on the input texture using the Sobel operator. It calculates the intensity gradients in the horizontal and vertical directions and combines them to detect edges. </p>"},{"location":"sobelEdgeDetection.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>threshold</code> Float: The threshold value to determine the intensity at which edges are detected. Default: <code>0.2</code></p>"},{"location":"sobelEdgeDetection.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader sobelEdgeDetection;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  sobelEdgeDetection = loadShader(\"sobelEdgeDetection.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  sobelEdgeDetection.set(\"threshold\", 0.2);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(sobelEdgeDetection);\n}\n</code></pre>"},{"location":"solarize.html","title":"Solarize","text":"<p>Inverts colors based on the intensity of pixel colors. If the average intensity of a pixel's color is above a specified threshold, the colors are inverted, creating a solarization effect.</p>"},{"location":"solarize.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>resolution</code> Vec2: The resolution of the input texture. Default: <code>vec2(1.0)</code> <code>threshold</code> Float: The intensity threshold above which colors will be inverted. Ranges from 0.0 to 1.0. Default: <code>0.5</code></p>"},{"location":"solarize.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader solarize;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  solarize = loadShader(\"solarize.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  solarize.set(\"threshold\", 0.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(solarize);\n}\n</code></pre>"},{"location":"static.html","title":"Static","text":"<p>Combines Sobel operator for edge detection and stippling. The Sobel operator calculates the intensity gradient of the image, and the stippling effect adds random dots to the edges, creating an TV static appearance.</p>"},{"location":"static.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>threshold</code> Float: The threshold for edge detection. Pixels with intensity above this threshold will be treated as edges.Default: <code>0.05</code> <code>stippleDensity</code> Float: The density of stippling dots to be added to the ink effect. A lower value results in more dots.Default: <code>0.99</code></p>"},{"location":"static.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader staticShader;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  staticShader = loadShader(\"static.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  staticShader.set(\"threshold\", 0.05);\n  staticShader.set(\"stippleDensity\", 0.99);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(staticShader);\n}\n</code></pre>"},{"location":"threshold.html","title":"Threshold","text":"<p>Applies a threshold to a texture, converting it to a binary black and white image based on a specified threshold value.</p>"},{"location":"threshold.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>threshold</code> Float: The threshold value that determines the cutoff point. Pixels with grayscale values above this threshold will be set to white, and those below will be set to black. Default: <code>0.5</code></p>"},{"location":"threshold.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader threshold;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  threshold = loadShader(\"threshold.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  threshold.set(\"threshold\", 0.5);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(threshold);\n}\n</code></pre>"},{"location":"unsharpMasking.html","title":"Unsharp Masking","text":"<p>Performs unsharp masking to enhance image sharpness. Unsharp masking involves subtracting a blurred version of the image from the original and then adding the result back to the original image. </p>"},{"location":"unsharpMasking.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>strength</code> Float: The strength of the unsharp masking effect. A higher value increases the sharpening effect. Default: <code>2.0</code></p>"},{"location":"unsharpMasking.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader unsharpMasking;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  unsharpMasking = loadShader(\"unsharpMasking.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  unsharpMasking.set(\"strength\", 2.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(unsharpMasking);\n}\n</code></pre>"},{"location":"usage.html","title":"Usage","text":"<p>Once FIP has been added to your libraries, to use an effect you:</p> <ol> <li>Import FIP</li> <li>Specify in <code>size()</code> the P2D or P3D renderer, but not the default renderer (Why?).</li> <li>Load the shader you want, using <code>loadShader()</code>.</li> <li>Call <code>filter()</code>, passing in the shader name.</li> </ol> <pre><code>import fip.*; // Import the FIP library\n\nPShader glitch;\nPImage ireland;\n\nvoid setup() {\n    size(1000, 1000, P3D); // Set up the canvas with a renderer (P3D in this case)\n\n    glitch = loadShader(\"glitch.glsl\"); // Load the glitch shader\n\n    ireland = loadImage(\"ireland.jpg\");\n}\n\nvoid draw() {\n    image(ireland, 0, 0, width, height);\n\n    filter(glitch); // Apply the glitch shader\n}\n</code></pre> Image with no effects Image with glitch effect applied"},{"location":"vignette.html","title":"Vignette","text":"<p>Adds a vignette effect to the texture.</p>"},{"location":"vignette.html#parameters","title":"Parameters","text":"<p><code>texture</code> Texture: The input texture to be filtered. Default: <code>The entire canvas</code> <code>texOffset</code> Vec2: The offset used for sampling neighboring pixels. Default: <code>(1.0 / width, 1.0 / height)</code> <code>vignetteStrength</code> Float: Strength of the vignette effect. Range: 0.0 (none) to 1.0 (maximum). Default: <code>0.8</code> <code>vignetteFalloff</code> Float: Rate at which the vignette diminishes. Default: <code>1.0</code> <code>vignetteSign</code> Float: Direction of the vignette effect. -1.0 (inward) or 1.0 (outward). Default: <code>1.0</code> <code>vignetteSize</code> Float: Overall size of the vignette effect. Default: <code>1.0</code></p>"},{"location":"vignette.html#example","title":"Example","text":"<pre><code>import fip.*;\n\nPShader vignette;\n\nPImage ireland;\n\nvoid setup() {\n  size(1000, 1000, P3D);\n\n  vignette = loadShader(\"vignette.glsl\");\n\n  ireland = loadImage(\"ireland.jpg\");\n\n  vignette.set(\"vignetteStrength\", 0.8);\n  vignette.set(\"vignetteFalloff\", 1.0);\n  vignette.set(\"vignetteSign\", 1.0);\n  vignette.set(\"vignetteSize\", 1.0);\n}\n\nvoid draw() {\n  image(ireland, 0, 0, width, height);\n\n  filter(vignette);\n}\n</code></pre>"}]}